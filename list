1. Sum

 (1) Prefix-Sum, Hashmap
 
   523 https://leetcode.com/problems/continuous-subarray-sum/

   560 https://leetcode.com/problems/subarray-sum-equals-k/

   325 https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/

   (!) 209 https://leetcode.com/problems/minimum-size-subarray-sum/solution/
   Find the continous subarray sum >= s

   Using pre-fix sum O(nlogn), no hashmap
   Use pre-fix sum array and find sum + s lower_bound in log(n)

   Using two pointer O(n)

   304 https://leetcode.com/problems/range-sum-query-2d-immutable/
   2D Pre-fix Sum array O(1) get function
   303 https://leetcode.com/problems/range-sum-query-immutable/
   Simple Pre-fix Sum array O(1) get function

   689 https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/
   In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.
   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.
   Return the result as a list of indices representing the starting position of each interval (0-indexed). 
   If there are multiple answers, return the lexicographically smallest one.
   Input: [1,2,1,2,6,7,5,1], 2
   Output: [0, 3, 5]
   Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
   We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

   Pre-sum, Store index in pos_left, pos_right(pos_right[i] = i + k)
   pos_left[i] = i - k, from k to n - 2k, (further no enough space on the right for mid and right parts)
   pos_right[i] = i + k, from n - 2k to k
   loop from k to n - 2k 
 
 (2) DP
   416 https://leetcode.com/problems/partition-equal-subset-sum/
   Given a non-empty array containing only positive integers, 
   find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
   Input: [1, 5, 11, 5]
   Output: true
   Explanation: The array can be partitioned as [1, 5, 5] and [11].
   
   494 https://leetcode.com/problems/target-sum/
   You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. 
   Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
   Find out how many ways to assign symbols to make sum of integers equal to target S.
   
   Brute Force: DFS, O(2^n) n: size of array.
   From index 0 to n - 1, try +nums[i], -nums[i] every call of dfs.
   
   DP: (The sum of elements in the given array will not exceed 1000.) So use 2d dp array of size n * 2001.
   
   Base: dp[0][nums[0] + 1000] = 1, dp[0][-nums[0] + 1000] += 1.
   For i from 0 to n - 1
    For sum from -1000 to 1000
      if (dp[i][sum + 1000] > 0)
        dp[i][sum + 1000 + nums[i]] += dp[i - 1][sum + 1000];
        dp[i][sum + 1000 - nums[i]] += dp[i - 1][sum + 1000];
   Return dp[n - 1][S + 1000];    
   
 
 (3) Other
   15 https://leetcode.com/problems/3sum/
   1 https://leetcode.com/problems/2sum/
 
 (4) Nested List
   339 https://leetcode.com/problems/nested-list-weight-sum/
   Input: [[1,1],2,[1,1]]
   Output: 10 
   Explanation: Four 1's at depth 2, one 2 at depth 1.
   
   Basic DFS, add one level each list
   
   364 https://leetcode.com/problems/nested-list-weight-sum-ii/
   Input: [[1,1],2,[1,1]]
   Output: 8 
   Explanation: Four 1's at depth 1, one 2 at depth 2.
   
   Input: [1,[4,[6]]]
   Output: 17 
   Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.
   
   The most inner Integer is at level 1.
   Two int variables, weighted and unweighted. 
   unweighted += item.getInteger();
   If !item.isInteger(), push the list into next level
   swap two list
   
 (5) Binary Tree Path
   124 https://leetcode.com/problems/binary-tree-maximum-path-sum/
   
   129 https://leetcode.com/problems/sum-root-to-leaf-numbers/
   DFS, pass sum * 10 + root->val as new sum to next level(children)
   
   113 https://leetcode.com/problems/path-sum-ii/
   DFS, base: check target == root->val
   Use reference, no RETURN in check condition. 
 (6) Backtrack in Array
   39 https://leetcode.com/problems/combination-sum/
   DFS, start with every index, (next dfs may start with the same index)
   To avoid duplicates: 1. no dulicates in the input, 2. sort before dfs.
   
2. DFS Backtrack
   (1) Add operation
     494 https://leetcode.com/problems/target-sum/
     + or - on every number 
     Can be optimized using dp

   (2) Word Break
     139 https://leetcode.com/problems/word-break/
     Remember Cache! ç”¨index cacheå°±å¯ä»¥
     140 https://leetcode.com/problems/word-break-ii/
    ï¼ˆæœ‰æ›´ç®€å•çš„è§£æ³•ï¼Œè¡¥ä¸Šï¼‰

   (3) Word Ladder
     127 https://leetcode.com/problems/word-ladder/
     Return æœ€çŸ­è·¯å¾„ from beginWord to endWord
     O(m*n)
     Check if endWord in wordList before search
     BFS from beginWord, try to change a-z for every position on current word(front of the queue)
     As long as reach endWord, return step directly.

     126 https://leetcode.com/problems/word-ladder-ii/
     Return every shortest path from beginWord to endWord
     O(2^n)
     Best Solution so far
     Maintain two unordered_set<string> curr, next;
     Maintain unordered_map<string, vector<string>> parents;
     While (!curr.empty()) {
       remove every word in curr from dict;
       add children for every word in dict to next;
       if next empty break
       if next contains endWord, do dfs to get paths and break;
       swap(curr, next)
       clear next
     }
     add children: try to change a-z for every position on current word, add into next if in dict
     DFS get paths: from endWord to beginWord, try every parents, reverse path before return
  (4) Graph Painting 
      785 https://leetcode.com/problems/is-graph-bipartite/
      ç”¨intä»£è¡¨0å’Œ1ä»£è¡¨é¢œè‰²ï¼Œæ¢é¢œè‰²1-colorå³å¯
  568 https://leetcode.com/problems/maximum-vacation-days/
  78 https://leetcode.com/problems/subsets/ From every position, jump from 1 to n(if in bound)
  394 [RECURSION!] https://leetcode.com/problems/decode-string/
       while (i < s.length() && s[i] != ']') {
       
       }
  
  
  
      

3. Palindrome
  266 https://leetcode.com/problems/palindrome-permutation/
  è¿™ä¸ªé¢˜å’ŒPalindromeå‡ ä¹æ— å…³ã€‚
  æœ€ä¼˜è§£æ˜¯ç”¨hashmapå­˜ä¸€æ¬¡æ¯ä¸ªcharçš„æ¬¡æ•°ï¼Œç„¶åå†loopä¸€æ¬¡ï¼Œmaintainä¸€ä¸ªcount variableï¼Œæ¯æ¬¡ç¢°åˆ°å‡ºç°æ¬¡æ•°ä¸º1çš„count++ï¼Œå½“countå¤§äº1ç›´æ¥break
  return count <= 1
  
  680 https://leetcode.com/problems/valid-palindrome-ii/
  You may delete at most one character. Judge whether you can make it a palindrome.

  Two pointer, from the beginning and the end, 
  if not the same, try remove one of them and check the rest need to be a valid Palindrome.
  
  1216. Valid Palindrome III https://leetcode.com/problems/valid-palindrome-iii/
  
  Brute Force: DFS
  
  Optimized: DFS with memo O(n^2), hardcore is to find a workable hash function
  i * 1001 * 1001 + j * 1001 + k, OR hash string i + "," + j + "," + k
  
  Optimized: DP Longest subsequence, return dp[0][n - 1] + k >= n

  125 https://leetcode.com/problems/valid-palindrome/
  Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
  Input: "A man, a plan, a canal: Panama"
  Output: true

  Two pointer, from the beginning and the end, 
  while not isalnum i++, j--, compare lowercase and move pointers.

  9 https://leetcode.com/problems/palindrome-number/

  Two corner cases: 1. negative return false directly, 2. x % 10 == 0 && x != 0, false directly.
  O(log(n)), while x > last_half, x /= 10 each iteration and keep track of the reversed last half.

  647 https://leetcode.com/problems/palindromic-substrings/ï¼ˆä¼¼ä¹æœ‰ä¸€ä¸ªO(1) time solutionï¼‰
  Given a string, your task is to count how many palindromic substrings in this string.
  The substrings with different start indexes or end indexes are counted as different substrings 
  even they consist of same characters.

  2D DP n * n
  Initialization: dp[i][i] = 1; count = n;
  For i from n - 2 to 0
    For j from i + 1 to n
      If (s[i] == s[j]) 
         If (j == i + 1) dp[i][j] = 1;
         Else dp[i][j] = dp[i + 1][j - 1];
      count += dp[i][j];
  return count;

  O(1) memory:
  int n = s.length(), count = 0;
  for (int i = 0; i < n; i++) {
      for (int l = i, r = i; l >= 0 && r < n && s[l] == s[r]; l--, r++) count++;
      for (int l = i, r = i + 1; l >= 0 && r < n && s[l] == s[r]; l--, r++) count++;
  }
  return count;
  
  5 https://leetcode.com/problems/longest-palindromic-substring/
  Palindromic substringçš„dpé¢˜å¯ä»¥ç”¨expandAroundCenterçš„åŠæ³•å°†spaceé™è‡³O(1)
  
  string longestPalindrome(string s) {
      int n = s.length(), start = 0, end = 0;
      for (int i = 0; i < n; i++) {
          int lenOdd = expandAroundCenter(s, i, i);
          int lenEven = expandAroundCenter(s, i, i + 1);
          int len = max(lenOdd, lenEven);
          if (len > (end - start)) {
              end = i + len / 2;
              start = i - (len - 1) / 2;
          }
      }
      return s.substr(start, end - start + 1);
  }
  int expandAroundCenter(string& s, int i, int j) {
      int left = i, right = j, n = s.length();
      while (left >= 0 && right < n && s[left] == s[right]) {
          left--, right++;
      }
      return right - left - 1;
  }
  
  516 https://leetcode.com/problems/longest-palindromic-subsequence/
  2D DP(n * n)
  dp[i][j] longest palindromic subsequence from i to j inclusive
  init: dp[i][i] = 1;
  return: from 0 to n - 1 dp[0][n - 1]
  int longestPalindromeSubseq(string s) {
      int n = s.length();
      vector<vector<int>> dp(n, vector<int>(n, 0));
      for (int i = 0; i < n; i++) dp[i][i] = 1;
      for (int i = n - 2; i >= 0; i--) {
          for (int j = i + 1; j < n; j++) {
              if (s[i] == s[j]) {
                  if (j == i + 1) dp[i][j] = 2;
                  else dp[i][j] = dp[i + 1][j - 1] + 2;
              } else {
                  dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
              }
          }
      }
      return dp[0][n - 1];
  }
  
  214 https://leetcode.com/problems/shortest-palindrome/
  O(n^2): T(n) = T(n - 2) + O(n) 
  Two pointers, from begining and end, i increase by one when s[i] == s[j]
  if i == n return s;
  extra = s.substr(i) is the extra part in this call.
  ret = reversed(extra) + shortestPalindrome(s.substr(0, i)) + extra;
  
  336 https://leetcode.com/problems/palindrome-pairs/
  Brute force: concatenate every two of the strings and call checkValid() O(n^2 * k)
  Optimized: O(k^2 * n)
  Build hashmap containing reversed words from input as key, the index in input as value.
  For i from 0 to n - 1
    For j from 0 to n - i?
      string left = words[i].substr(0, j);
      string right = words[i].substr(j + 1);
      if (dict.find(left) != dict.end() && dict[left] != i && isPalindrome(right)) ret.push_back({i, dict[left]});
      if (dict.find(right) != dict.end() && dict[right] != i && isPalindrome(left) && !left.empty()) ret.push_back({dict[right], i});
  
4. Search
   ä¸€å®šè¦æƒ³æ€ä¹ˆmark visitedï¼
   (0) Basic Search 
       1091 [BFS] https://leetcode.com/problems/shortest-path-in-binary-matrix/ mark [visited] as 1
       329 [DFS] https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ å¯¹æ¯ä¸ªindexéƒ½searchï¼Œdfsè¿”å›ä¸Šä¸‹å·¦å³æœ€å¤§çš„+1ï¼Œè®°å¾—cache
       200 https://leetcode.com/problems/number-of-islands/[Union find]é€‚åˆæ­¤é¢˜å˜å½¢
       305 [Union find] https://leetcode.com/problems/number-of-islands-ii/ è¿™ä¸ªé¢˜ä¸æŸ¥visited, roots[child] == -1 means grid[][] = 0
       79 https://leetcode.com/problems/word-search/ O(m*n*4^k)è¿™é“é¢˜æ²¡æœ‰memo, å¯¹æ¯ä¸ªcharæ£€æŸ¥ä¸€éï¼Œmark visitedæ˜¯æ”¹æˆç©ºæ ¼å¹¶åœ¨recursionåæ”¹å›æ¥
       529 https://leetcode.com/problems/minesweeper/ å¼€å§‹bfså‰å…ˆæŸ¥start pointæ˜¯eçš„ä¸¤ç§æƒ…å†µ
       
       
   (1) The Maze
       490 https://leetcode.com/problems/the-maze/

       DFS, return bool, O(m*n)
       Start DFS from start[0],start[1].
       Base case: out of bound(4) || if maze[row][col] != 0
       Mark Visited: maze[row][col] = 2;
       Try four direction(while loop) until the end(hit a wall), do dfs from the end
       return dfs(left) || dfs(right) || dfs(up) || dfs(down).

       505 https://leetcode.com/problems/the-maze-ii/

       Find the shortest distance for the ball to stop at the destination
       BFS O(m*n) return pathLength
       Build another distance 2D vector, starting with INT_MAX, and update it duing the traversal.
       Return dist[end[0]][end[1]] == INT_MAX ? -1 : dist[end[0]][end[1]];

   (2) Walls and Gates/Shortest Distance from All Buildings
       286 https://leetcode.com/problems/walls-and-gates/
           Fill each empty room with the distance to its nearest gate. 
           If it is impossible to reach a gate, it should be filled with INF

           DFS/BFS
           Do search on every gate, 
           Update when grid[next_r][next_c] > grid[r][c] + 1, 
           Start next search from (next_r, next_c) 

       317 https://leetcode.com/problems/shortest-distance-from-all-buildings/

           BFS è¿™é“é¢˜å› ä¸ºè¦sum up all distanceï¼Œæ‰€ä»¥æ›´æ–°visitedçš„æ–¹å¼æ˜¯å¯¹äºæ¯ä¸€ä¸ªbuildingçš„searchï¼Œè¦æ‰¾çš„targetæ•°å­—ä¸ä¸€æ ·
           ç¬¬ä¸€ä¸ªbuilding search 0ï¼Œæ¯ä¸ªpushè¿›queueçš„ç©ºåœ°éƒ½è¦grid[][]--ï¼›å¯¹äºä¸‹ä¸€ä¸ªbuildingï¼Œ search -1ï¼Œ ä»¥æ­¤ç±»æ¨ã€‚
           Also need to maintain another distance matrix to do the sum.
           At last, traverse the distance matrix and return the smallest distance in it.
    (3) Infinite Board
        1197 https://leetcode.com/problems/minimum-knight-moves/ è®°visitedï¼step<=3å¯ä»¥ä¸åŒæ–¹å‘è·³
    (4) Set Matrix Zeroes 
        73 https://leetcode.com/problems/set-matrix-zeroes/
           search i from 0 to n - 1, j from 1 to n - 1
           If any first col is 0, mark bool as true and mark all cols 0 later
           If there is 0, mark matrix[i][0] and matrix[0][i] as 0.
           If matrix[0][0] is 0, all first row 0.
 


5. Recursive Data Structures
(1) Copy/Clone Same data structure
  ç”¨unordered_map<Node*, Node*>è®°å½•å·²ç»buildçš„æ–°nodeï¼Œkey: åŸæœ‰çš„ï¼Œvalue: æ–°çš„
  æ‰¾åˆ°äº†returnï¼Œnull returnï¼Œ
  build rootï¼ŒåŠ å…¥cacheï¼ˆï¼ï¼‰
  åŠ å…¥neighbors
  133 https://leetcode.com/problems/clone-graph/
  138 https://leetcode.com/problems/copy-list-with-random-pointer/
(2) Pure Linked List
  143 https://leetcode.com/problems/reorder-list/
  Given a singly linked list L: L0â†’L1â†’â€¦â†’Ln-1â†’Ln,
  reorder it to: L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’â€¦
  findHalf(2), reverse last half(3), and merge(Recursion)
  
  (BOTH) 206 https://leetcode.com/problems/reverse-linked-list/
  (BOTH)(Merge) 21 https://leetcode.com/problems/merge-two-sorted-lists/
  (Iterative) 19 https://leetcode.com/problems/remove-nth-node-from-end-of-list/
     ç”¨fast and slow pointeråšï¼Œfastå’Œslow start from dummy headï¼Œfastå…ˆèµ°n+1æ¬¡ï¼Œç„¶åå†ä¸€èµ·updateï¼Œç›´åˆ°faståˆ°null
  (Iterative) 328 https://leetcode.com/problems/odd-even-linked-list/
     odd even pointerï¼Œå½¢æˆä¸¤æ¡listï¼Œæœ€åå°†oddçš„nextè¿åˆ°evençš„headä¸Š
  (BOTH)(Merge)23 https://leetcode.com/problems/merge-k-sorted-lists/
     1. Priority Queue. O(nlogk), O(k).
     2. Merge Sort. O(nlogk), O(n).
  (Iterative) 160 https://leetcode.com/problems/intersection-of-two-linked-lists/
     O(n), O(1) ä¸¤ä¸ªæŒ‡é’ˆfrom p1 = a and p2 = bï¼Œwhen p1 reaches end, redirect p1 to b, when p2 reaches end, redirect p2 to a.
  (Recursive) 430 https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/ O(n),O(n)
     Similar to 114 https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
  (Iterative) 708 https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/
     If list empty, build, set pointers and return.
     While(true) {
        if (3conditions) {
           set inserted = true;
        }
        move pointers;
        if goes back to head, break;
     }
     check inserted, if not, insert right after head // This is for size 1 list
     return head
     
(3) (!Recursive) Linked List - Binary Tree
    426 https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/submissions/
    
    Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.
    
    114 https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
    
    Given a binary tree, flatten it to a linked list in-place.
    Set root->right = func(root->left), root->left = NULL
    
    109 https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/
    Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
    
    O(nlogn), O(logn): æ€è·¯æ˜¯æ‰¾midpointä½œä¸ºrootï¼Œç„¶åå·¦ä¸ºleftï¼Œå³è¾¹ä¸ºrightï¼Œå®é™…æ“ä½œä¸­ï¼Œä»»ä½•æƒ…å†µå·¦ï¼Œrootï¼Œå³å­˜åœ¨é‡å ï¼Œéƒ½ä¼šseg faultã€‚
    
    é¿å…bugçš„å‡ ä¸ªåœ°æ–¹ï¼š
    1. base return nullï¼Œ
    2. å¦‚æœslowæ˜¯nullï¼Œreturn nullï¼Œ
    3. å¦‚æœslowæ˜¯headï¼Œåº”è¯¥ç›´æ¥return rootï¼Œè€Œä¸å†è¿›è¡Œdfsï¼ˆå¾ˆè¿·ï¼‰ï¼Œ
    4. set prev->next = NULLå‰æ£€æŸ¥prev
    
    O(n), 0(n): convert list to array, and build
    O(n), O(1): Store a public ListNode* curr, count length first, set left-right boundary, build left part first.
    
    ListNode* curr = NULL;
    TreeNode* sortedListToBST(ListNode* head) {
        int n = 0;
        curr = head;
        for (ListNode* curr = head; curr; curr = curr->next) n++;
        return dfs(0, n - 1);
    }
    TreeNode* dfs(int left, int right) {
        if (left > right) return NULL;
        int mid = (left + right) / 2;
        TreeNode* prev = dfs(left, mid - 1);
        TreeNode* root = new TreeNode(curr->val);
        if (left == right) {
            curr = curr->next;
            return root;
        }
        root->left = prev;
        curr = curr->next;
        root->right = dfs(mid + 1, right);
        return root;
    }
(4) Iterator
    314 https://leetcode.com/problems/flatten-nested-list-iterator/
    å¾ˆå®¹æ˜“å¿˜ï¼
    maintain two stack<vector<Integer>::iterator> begins, ends;
    Constructor: push begin to begins, end to ends in constructor
    
    hasNext(): 
    while (!begins.empty()) { // while loop is to get inner lists, each pop, we move to the next item
        if (begins.top() == ends.top()) {
            begins.pop();
            ends.pop();
        } else {
            auto it = begins.top();
            if (it->isInteger()) return true;
            begins.top()++ // move to next one
            begins.push(it->getList().begin());
            ends.push(it->getList().end());
        }
    }
    return false;
    
    int next() {
        hasNext();
        return (st.top()++)->getInteger(); // remember to move to next one in the current list
    }
    
    173 https://leetcode.com/problems/binary-search-tree-iterator/
    O(1) amrotized, O(h)
    
    145 https://leetcode.com/problems/binary-tree-postorder-traversal/
        å…ˆæ¨å·¦ï¼Œç”¨ä¸€ä¸ªprev nodeè®°å½•åˆšåˆšpopè¿‡çš„nodeé¿å…é‡å¤æ¨right
  (5) Tree
  
    [1]. Traverse but not return recursive call
       Be Careful about what to return when !root and !root->left && !root->right (recursive call may not change the return value)
       [124] https://leetcode.com/problems/binary-tree-maximum-path-sum/
       [543] https://leetcode.com/problems/diameter-of-binary-tree/
       (!) [298] https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/
       
       int ret = 0;
       int longestConsecutive(TreeNode* root) {
           if (!root) return 0;
           dfs(root, 0, root->val);
           return ret;
       }
       void dfs(TreeNode* root, int count, int target) {
           if (!root) return;
           if (root->val == target) count = count + 1;
           else count = 1;
           ret = max(ret, count);
           dfs(root->left, count, root->val + 1);
           dfs(root->right, count, root->val + 1);
       }
       [549] https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/
             pair<int, int> first: increase from root, second: decrease from root
       
    [2]. DFS to fill the returned value
       [DFS]199 https://leetcode.com/problems/binary-tree-right-side-view/
       [LCA] 865 https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
       [DFS] 257 https://leetcode.com/problems/binary-tree-paths/
       [DFS][BFS] 575 https://leetcode.com/problems/find-largest-value-in-each-tree-row/
    [3]. Return recursive call
       98 https://leetcode.com/problems/validate-binary-search-tree/
       111 [BFS BETTER] https://leetcode.com/problems/minimum-depth-of-binary-tree/
       104 https://leetcode.com/problems/maximum-depth-of-binary-tree/
       100 https://leetcode.com/problems/same-tree/
       
    [4]. Traversal
       vertical orderç”¨dfsä¼šå¢åŠ å¤æ‚åº¦ï¼Œå› ä¸ºè¦sort heightï¼Œç”¨bfsè‡ªå¸¦sorting
       è¦çœ‹æ¸…åŒä¸€ä½ç½®çš„returné¡ºåºï¼Œä¸€èˆ¬traverseéƒ½æ˜¯éœ€è¦levelå’Œheightä¸¤å˜é‡
       987 https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
       314 https://leetcode.com/problems/binary-tree-vertical-order-traversal/
       
       [BFS] 863 https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
             Build parents map first using DFS, then use BFS to count distance as a graph problem
       [BFS] 958 https://leetcode.com/problems/check-completeness-of-a-binary-tree/
             ç”¨vectoræˆ–queueéƒ½å¯ä»¥ï¼Œnullè¿›å»ï¼Œæ£€æŸ¥æ–¹æ³•æ˜¯nullåé¢æ²¡æœ‰énullçš„nodeï¼ˆç”¨boolæˆ–è€…move indexï¼‰
       [BFS][LevelOrder] 637 https://leetcode.com/problems/average-of-levels-in-binary-tree/
       [BFS] 103 https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
       [Iterative] 145 https://leetcode.com/problems/binary-tree-postorder-traversal/
      
    [5]. BST BSTè€ƒè™‘boundaryï¼ï¼
       270 O(h) https://leetcode.com/problems/closest-binary-search-tree-value/
       
    [6]. Build Tree
       297 https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
           ç”¨stringstreamï¼Œnullç”¨#ï¼Œç”¨spaceåˆ†å¼€
       428 https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/
           stringstreamå­˜çš„æ˜¯valå’Œchildren sizeï¼Œspaceåˆ†å‰²
       1008 https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
            éœ€è¦ä¼ boundary
       
       
    [7]. LCA Sequence 
         236 https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
         ç”¨parentå°±æ˜¯hashmapä»ä¸€ä¸ªèµ°åˆ°rootå†ä»å¦ä¸€ä¸ªèµ°ï¼Œé‡åˆ°å³return
         ç”¨recursionåšå°±æ˜¯post order traversalï¼Œå·¦nullè¿”å›å³ï¼Œå³nullè¿”å›å·¦ï¼Œéƒ½æœ‰è¿”å›rootï¼Œè¿™é‡Œçš„return nodeåƒæ˜¯ä¸€ä¸ªboolè¯æ˜æœ‰oræ²¡æœ‰
         865 https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
         1123 https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

6. Merge Interval
  56 https://leetcode.com/problems/merge-intervals/
  Input: [[1,3],[2,6],[8,10],[15,18]]
  Output: [[1,6],[8,10],[15,18]]

    å…ˆsort, curr = intervals[0]
    push at last

  986 https://leetcode.com/problems/interval-list-intersections/
    two pointers,è°å…ˆç»“æŸè°++

  57 https://leetcode.com/problems/insert-interval/
    input has been sorted by start time
    1. One index variable, push every interval while intervals[i][1] < newIntervals[0]
    2. merge, while intervals[i][0] < newIntervals[1], update newIntervals[0], newIntervals[1]
    3. push newIntervals
    4. push the rest
  253 https://leetcode.com/problems/meeting-rooms-ii/
    O(nlogn) priority_queue, push intervals[i][1] only
  1094 O(n) Bucket Sort https://leetcode.com/problems/car-pooling/
  452 https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ 
      Sort by end time,
      for loop, if found start time later than current end_time, count++, re-set end_time;
  435 https://leetcode.com/problems/non-overlapping-intervals/
  ????? https://leetcode.com/problems/add-bold-tag-in-string/
7. Parentheses

20 https://leetcode.com/problems/valid-parentheses/
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

O(n), O(n) ç”¨stackï¼Œå·¦æ‹¬å·æ¨å…¥ï¼Œå³æ‹¬å·æ£€æŸ¥ï¼Œvalid popï¼Œinvalid returnï¼Œä¸­é—´ä»»ä½•æ—¶å€™stackç©ºäº†éƒ½falseï¼Œæœ€åæŸ¥stackæ˜¯å¦ç©ºäº†

22 https://leetcode.com/problems/generate-parentheses/
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

DFS, left right start with n 
If(left > 0), dfsåŠ å·¦æ‹¬å·
If(right > left) dfsåŠ å³æ‹¬å·

921 https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
åˆ†åˆ«è®°å¤šå‡ºæ¥çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æœ€ååŠ èµ·æ¥return

1249 https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
If: s[i] is one of  '(' , ')' and lowercase English letters.
Loop from left to right, if meet ')' when count < 0, change char to *
Loop from right to left, if count > 0, change '(' to *, decrease count by 1
Mark extra parentheses as '*', and loop again, add chars not '*'
Else, use helper function, removeParentheses()
Remove s ()
reverse the removed s, remove again )(
reverse again, return 

301 https://leetcode.com/problems/remove-invalid-parentheses/
1249å‡çº§ç‰ˆ, return all

DFS
ç®—extra left, extra right
dfs backtrack
*** åŒä¸€ä¸ªæ‹¬å·å†…ï¼Œæ˜¯å¦removeæ˜¯æ²¡æœ‰elseçš„ï¼Œéƒ½è¦æŸ¥ æ˜¯if if è€Œéif else

32 https://leetcode.com/problems/longest-valid-parentheses/submissions/
ä¸‰ç§æ–¹æ³•ï¼Œæœ€ç®€å•çš„æ˜¯stack
1.Stack. O(n), O(n)
stack storing index
left parenthese, push(i)
right, pop
if not empty, update ret
if empty, push i
2. DP
3. Two pointers. O(n), O(1) æŸ¥ä¸€éå·¦ï¼Œrightè¶…è¿‡left take max of ret, å†æŸ¥ä¸€éå³

8. Operator/Calculaters

9. Math related
  (1) Addition/Subtraction
      67 Add binary https://leetcode.com/problems/add-binary/
      2 Add Two Numbers https://leetcode.com/problems/add-two-numbers/
      415 Add Strings https://leetcode.com/problems/add-strings/
  (2) Division
      29 https://leetcode.com/problems/divide-two-integers/submissions/
      OVERFLOW because of INT_MIN
      åœ¨æ“ä½œå‰è§£å†³æ‰€æœ‰overflowçš„å¯èƒ½
      è½¬æ¢æˆabs
      ç”¨binary searchçš„æ–¹æ³•ä¸æ–­çš„ä»dvdå‡å»dvsçš„å€æ•°ï¼Œè¯¥å€æ•°å‘ˆ2çš„æŒ‡æ•°æ¬¡å¢é•¿
      å¢é•¿çš„æ–¹æ³•ï¼štmp << 1 ç„¶åä»dvdä¸­å‡å»ï¼Œquotient += m
      æ£€æŸ¥ç¬¦å·å¹¶return
  (3) Multiply
      43 https://leetcode.com/problems/multiply-strings/
      ä¸¤ä¸ªfor loopï¼Œinner loopå‰set carry = 0ï¼Œåœ¨inner loopå†…åšåŠ æ³•ï¼Œä½†è¦è®°å¾—åŒæ ·çš„ä½ç½®è¦ç´¯åŠ  +=
      åœ¨inner loopå¤–ï¼Œouter loopå†…ï¼Œç»“æŸåŠ æ³•åï¼Œæ£€æŸ¥carryï¼ŒåŠ åˆ°i - 1ä¸Šï¼Œå¦‚æœiæ˜¯0ï¼Œå¢åŠ ä¸€ä½
      æœ€åæ£€æŸ¥å‰é¢çš„leading zerosï¼Œå¹¶ä¸”trimæ‰ï¼Œreturn
  (4) Power
      50 https://leetcode.com/problems/powx-n/
      å¦‚æœnæ˜¯è´Ÿæ•°ï¼ŒæŠŠxå˜æˆ1/xï¼Œnå˜æ­£
      Recursion
      base å¦‚æœn == 0ï¼Œreturn 1, å¦‚æœn == 1ï¼Œreturn x
      å¦‚æœnä¸ºå¶æ•°ï¼Œreturn pow(x, n / 2) * pow(x, n / 2)
      nä¸ºå¥‡æ•°return pow(x, n / 2) * pow(x, n / 2) * x
  (5) Fraction to Recurring Decimal
      166 https://leetcode.com/problems/fraction-to-recurring-decimal/
      æŸ¥0ï¼ŒåŠ ç¬¦å·ï¼Œè½¬æˆabsï¼Œå¦‚æœæ•´é™¤returnï¼Œæ²¡æœ‰åŠ dotï¼Œbuild hashmap<long, int>è¿›å…¥whileloop (while(r))
      å…ˆæŸ¥æ˜¯å¦å¾ªç¯ï¼Œå¾ªç¯insertæ‹¬å·return
      ä¸å¾ªç¯æŠŠå½“å‰råŠ å…¥map, m[r] = ret.size();æŠŠrä¹˜10ï¼ˆå€Ÿä½é™¤æ³•ï¼‰ç»“æœåŠ ä¸Šå•†(r / d)ï¼ˆæ³¨æ„æ˜¯å•†ï¼‰; r %= d;
  (6) Valid Number
      65 https://leetcode.com/problems/valid-number/
      Rules: 1. Sign +/- only at the begin of the number or right after a e
             2. No e after e, No dot after e, e must after number appeared, e must followed by number
             3. No dot after dot, e can be after dot, No dot after e
             4. No other char except number, sign, e, dot, after trim
      return numSeen && numAfterE;
  (7) Bulb Switch
      Numbers from 1 to n (inclusive) can be grouped into 3 groups.
      1. primes
      2. square
      3. non-primes except square

      Primes will be turned on at 1 and itself -> off
      Non-primes will be turned on at every factor pairs. eg 6, (1 6), (2 3) -> off
      Squares will be turned on at factor pairs and itself. eg 4 (1 4), ->off, (2 2) ->on

      Therefore only the square numbers can be on at last.
      There are sqrt(n) number of square numbers from 1 to n(inclusive).

      int bulbSwitch(int n) {
          return sqrt(n);
      }
      
10. Stack
    636 https://leetcode.com/problems/exclusive-time-of-functions/ 
        è‡ªå®šä¹‰log structï¼Œæœ‰ç‚¹åƒæ‹¬å·é¢˜ï¼Œstartéƒ½pushï¼Œendå…ˆç®—intervalï¼Œ
        åœ¨å½“å‰idçš„retä½ç½®åŠ intervalï¼Œpopï¼Œåœ¨popåçš„topä½ç½®å‡å»interval
    71  https://leetcode.com/problems/simplify-path/
        ç”¨stringstream
          If emptyæˆ–è€…single dot continue
          else if ä¸ç©ºå¹¶ä¸”å½“å‰ä¸ºdouble dot pop
          else if ä¸æ˜¯dot dot push
        ç©ºäº†return/
        popç©ºstackå…¨éƒ¨åŠ å…¥ret
    
        
11. Matrix related
  (1) Traversal 
  766 https://leetcode.com/problems/toeplitz-matrix/
      ç”¨ä¸€ä¸ªunordered_map<int, int>è®°å½•ï¼Œkeyæ˜¯row index - col indexï¼Œvalueæ˜¯å¯¹åº”row colçš„val
      if not find, add, else compare and return
      O(1) Spaceæ˜¯ä¸ç”¨hashmapï¼Œæ¯æ¬¡éƒ½å’Œå·¦ä¸Šè§’æ¯”è¾ƒ
  498 https://leetcode.com/problems/diagonal-traverse/
      for sum from [0 to n * m - 1)
        for x from [0 to sum]
          
  (2) Sprial Matrix
  54 Spiral Matrix https://leetcode.com/problems/spiral-matrix/
  ç»§ç»­è½¬åœˆçš„ifæ¡ä»¶æ˜¯r2 > r1 && c2 > c1
  885 https://leetcode.com/problems/spiral-matrix-iii/
  rpos, cpos, dis(æ¨disä¸ªè¿›å»per direction), dir(å¥‡æ•°dirå¢åŠ dis)
  (3) Search
  240 https://leetcode.com/problems/search-a-2d-matrix-ii/
  O(m + n)ç»å…¸åšæ³•
  O(nlogn) Binary Search æ¯ä¸ªrowæ‰«ä¸€éï¼Œæœ‰trueå³returnï¼Œå¯¹each rowåšbinary search
  
  378 https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
  Minheap O(nlogm + n)
  Binary Search O(n*log(maxâˆ’min)) 
  Search value not index!
  int kthSmallest(vector<vector<int>>& matrix, int k) {
     int n = matrix.size();
     int lo = matrix[0][0], hi = matrix[n - 1][n - 1] + 1;
     while (lo < hi) {
         int mid = lo + (hi - lo) / 2;
         int count = 0, j = n - 1;
         for (int i = 0; i < n; i++) {
             while (j >= 0 && matrix[i][j] > mid) j--;
             count += j + 1;
         }
         if (count < k) lo = mid + 1;
         else hi = mid;
     }
     return lo;
  }
  
  (4) Sparse Matrix Compression
  311 https://leetcode.com/problems/sparse-matrix-multiplication/
  There is no better solution than O(m*n*k) given the input like this problem.
  However, we can do optimization if the input have already been compressed. 
    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {
       int m = A.size(), n = A[0].size(), k = B[0].size();
       vector<vector<int>> ret(m, vector<int>(k, 0));
       for (int i = 0; i < m; i++) {
           for (int j = 0; j < n; j++) {
               if (A[i][j] != 0) {
                   for (int h = 0; h < k; h++) {
                       ret[i][h] += A[i][j] * B[j][h];
                   }
               }
           }
       }
       return ret;
     }
   Do compression
     int m = A.size(), n = A[0].size(), k = B[0].size();
     vector<vector<int>> ret(m, vector<int>(k, 0));
     unordered_map<int, unordered_map<int, int>> map;
     for (int i = 0; i < m; i++) {
         unordered_map<int, int> tmp;
         for (int j = 0; j < n; j++) {
             if (A[i][j] != 0) {
                 tmp[j] = A[i][j];
             }
         }
         map[i] = tmp;
     }
     for (auto it : map) {
         for (int j = 0; j < k; j++) {
             for (auto itt : it.second) {
                 if (B[itt.first][j] != 0) {
                     ret[it.first][j] += B[itt.first][j] * itt.second;
                 } 
             }
         }
     }
    return ret;
  Sparse Vector Multiplication
  vector<pair<int, int>> a, vector<pair<int, int>> b.
  If sorted,  O(m+n)
    int i = 0;
    int j = 0;
    while (i < m && j < n) {
        ArrayList<Integer> pairA = a.get(i);
        ArrayList<Integer> pairB = b.get(j);
        if (pairA.get(0) < pairB.get(0)) {
            i++;
        } else if (pairA.get(0) > pairB.get(0)) {
            j++;
        } else {
            res += pairA.get(1) * pairB.get(1);
            i++;
            j++;
        }
    }
  If not, O(m*n) or sort first O(mlogm + nlogn)
     for (int i = 0; i < m; i++) {
         ArrayList<Integer> pairA = a.get(i);
         for (int j = 0; j < n; j++) {
             ArrayList<Integer> pairB = b.get(i);
             if (pairA.get(0) == pairB.get(0)) {//if their indices are the same, calculate and break
                 res += pairA.get(1) * pairB.get(1);
                 break;//pairA has been calculated, jump to next pair
             }
         }
     }
   If two inputs are sorted by index0, have same size, sometimes dense, sometimes sparse; two pointes + binary search
   ç”¨ä¸¤ä¸ªcountè®°å½•aè¶…å‡ºbå¤šå°‘orbè¶…å‡ºaå¤šå°‘ä¸ªindex
       int i = 0;
       int j = 0;
       int countA = 0;
       int countB = 0;
       while (i < m && j < n) {
           ArrayList<Integer> pairA = a.get(i);
           ArrayList<Integer> pairB = b.get(j);
           if (pairA.get(0) < pairB.get(0)) {
               i++;
               countA++;
               countB = 0;
               if (countA > Math.log(m)) {
                   i = search(a, i, m, pairB.get(0));
                   countA = 0;
               }
           } else if (pairA.get(0) > pairB.get(0)) {
               j++;
               countB++;
               countA = 0;
               if (countB > Math.log(n)) {
                   j = search(b, j, n, pairA.get(0));
                   countB = 0;
               }
           } else {
               res += pairA.get(1) * pairB.get(1);
               i++;
               j++;
               countA = 0;
               countB = 0;
           }
       }
   If two inputs are sorted by index0, input b is much larger than input a, iterate a and binary search b; O(m*logn) time
       int i = 0;
       int j = 0;
       while (i < m) {
           ArrayList<Integer> pairA = a.get(i++);
           j = search(b, j, n, pairA.get(0));
           ArrayList<Integer> pairB = b.get(j++);
           if (pairA.get(0) == pairB.get(0)) {
               res += pairA.get(1) * pairB.get(1);
           }
       }
       return res;
12. Binary Search
(first)(last)
    278 https://leetcode.com/problems/first-bad-version/
    34 https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ lower bound to upper bound
    33 https://leetcode.com/problems/search-in-rotated-sorted-array/ 
       ğŸˆšï¸duplicates æ‰¾åˆ°ä¸€ç«¯sorted
       å¦‚æœåœ¨sorted part search sortedä¸€ä¾§ å¦‚æœä¸åœ¨searchå¦ä¸€ä¾§
       If there are duplicates, if (nums[left] == nums[mid] && nums[mid] == nums[right]) left++, right--;
       Worst Case O(n)
    1060 https://leetcode.com/problems/missing-element-in-sorted-array/ right starts from nums.size()
    162 https://leetcode.com/problems/find-peak-element/
    1146 https://leetcode.com/problems/snapshot-array/
    658 https://leetcode.com/problems/find-k-closest-elements/ 
    
13. MultiSet
    MultiSet -- AVL tree allowing duplicates keys
    
    295 https://leetcode.com/problems/find-median-from-data-stream/
    maintain 2 iterators, 
    if odd size before insertion, move 
    if even size, insert in between 
    insert before lo, lo = hi--
    insert after hi(num >= *hi), lo++
    480 https://leetcode.com/problems/sliding-window-median/
    First push [0, k) into multiset window
    set med pointer at next(window.begin(), k / 2); 
    start iteration from [k to n)
    push med into ret first
    if i == n break and return
    window insert nums[i]
    if nums[i] < *mid mid--; // think about nums[i - k] is larger than mid, remove something later how to move the iterator
    if nums[i - k] <= *mid mid++; 
    erase(window.lower_bound(nums[i - k])) // erase the first one
    
14. Data Structure Design
    [CircularQueue] 622 https://leetcode.com/problems/design-circular-queue/
         Maintain 4 int variables and a vector. 
         first, last, curr_size, max_size. update last when enqueue, update first when dequeue
         last start with -1
    [CircularQueue] 346 https://leetcode.com/problems/moving-average-from-data-stream/
    [HashMap Array] 380 https://leetcode.com/problems/insert-delete-getrandom-o1/
    [LRU] 146 https://leetcode.com/problems/lru-cache/ 
              list<pair<int, int>> cache first key, second value
              unordered_map<int, list<pair<int, int>>::iterator> key: key, value: position in list
              stl list in c++ special function: splice 
              move iterator it to the begining of the list: splice(cache.begin(), cache, it);
              
15. Reservoir Sampling
    [ONLY THIS ONE] 398 https://leetcode.com/problems/random-pick-index/
    [Pre-Sum][Binary Search Upper] 528 https://leetcode.com/problems/random-pick-with-weight/
16. Trie
    å¦‚æœä¸åªæ˜¯26ä¸ªå­—æ¯ï¼Œç”¨unorderedmapå­˜children
    æœ‰çš„trieéœ€è¦å­˜stringï¼Œcountï¼ˆautocompleteï¼‰
    208 https://leetcode.com/problems/implement-trie-prefix-tree/ æ²¡æœ‰ä»»ä½•èŠ±æ ·
    211 https://leetcode.com/problems/add-and-search-word-data-structure-design/ åªæœ‰dotæ—¶æœ‰for loopï¼Œç”¨recursion check children
    642 https://leetcode.com/problems/design-search-autocomplete-system/ éå¸¸å¤æ‚
        å­˜ä¸€ä¸ªå…±ç”¨çš„maxHeap pq<pair<string, int>>, å…±ç”¨çš„string sè®°å½•æ‰€æœ‰åŠ å…¥çš„char, å…±ç”¨çš„trienode* currè®°å½•ç°åœ¨åˆ°äº†trie treeçš„å“ªé‡Œ
        Trienode: unordered_mapå­˜childrenï¼Œå­˜countï¼Œå­˜stringï¼ˆä¸åˆ°endå­˜empty stringï¼‰
        Constructor insertæ‰€æœ‰çš„string
        vector<string> input(c) {
          c==# insert, set s empty, set curr back to root, return empty
          s adds char, re-build empty pq, check curr and curr->children[c], move curr to curr->chilren if valid, set to null and return empty elsewise 
          search all children from curr
          clear pq and return top 3
        }
        Helpers: insert, search
17. Union Find
    Accounts Merge 721 https://leetcode.com/problems/accounts-merge/
      First nested For loop
      Build owner map, key: email, value, name
      Build email_groups for union find, each email belongs to one group at the beginning, key email, value email(Same)

      Second nested for loop
      Group emails, use the first email in accounts[i] as the parent for the group, set email_groups[email] = parent

      Third for loop grouped_emails(unordered_map<string, set<string>> key parent, set<string> all emails in this group
      Build grouped_emails, at this time, we need to merge accounts in different group with same parents to one group
      The idea is loop through all emails, grouped_emails[find(email)].insert(email);

      Fourth for loop
      add owner name and insert all emails in this group
    
18. [Greedy][array]
    277 https://leetcode.com/problems/find-the-celebrity/
    334 https://leetcode.com/problems/increasing-triplet-subsequence/ initä¸¤ä¸ªvariable to intmax, updateä¸¤ä¸ªæœ€å¤§å€¼, æ‰¾åˆ°å¤§äºæœ€å¤§çš„å³ä¸ºtrue æ‰¾æœ€å°å€¼
    414 https://leetcode.com/problems/third-maximum-number/ ä¸‰ä¸ªvariable, é‡åˆ°å¤§æ•°è¦æŠŠæ¯”è¿™ä¸ªæ•°å°çš„variableséƒ½swap,æœ€åæŸ¥ç¬¬ä¸‰å¤§variableæ˜¯ä¸æ˜¯int max still
19. Task Scheduleç³»åˆ—
    767 O(nlogA, A = 26) https://leetcode.com/problems/reorganize-string/
    621 O(n) https://leetcode.com/problems/reorganize-string/
    358 https://leetcode.com/problems/rearrange-string-k-distance-apart/ 
        right_bound starts from s.length(), decrease by 1 every push
        int iterations = min(k, right_bound);
        for (int i =0 ; i < iterations; i++) {
            if (pq.empty()) return "";
            ....
        }
        
    
20. Graph
    Topo Sort æœ€åæ£€æŸ¥çš„éƒ½æ˜¯processçš„countå’Œä¸€å…±çš„degree arrayçš„keyçš„æ•°é‡ä¸€ä¸ä¸€æ ·
    207 Return True or False https://leetcode.com/problems/course-schedule/
    210 ä¸207å®Œå…¨ä¸€æ ·, popçš„æ—¶å€™pushbackå³å¯ https://leetcode.com/problems/course-schedule-ii/
    
    
21. Sliding Window [Substring Search]
    438 https://leetcode.com/problems/find-all-anagrams-in-a-string/ i - j + 1 == p.size()åˆæ³•
    76 https://leetcode.com/problems/minimum-window-substring/ i - j + 1 < max_length update
    340 [è¿™é“é¢˜ä¸count] https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/ dict[c] == 0, eraseæ‰
    1004 https://leetcode.com/problems/max-consecutive-ones-iii/ count 0, while loop ç§»åŠ¨ j, update ret after while
    567 [è¿™é“é¢˜å¯ä»¥ä¸ç”¨pointer][ä»£ç å’Œ438ä¸€æ ·] https://leetcode.com/problems/permutation-in-string/
        è¿™é“é¢˜è¦make sure window remains s1.length()
        æ‰€ä»¥å…ˆä»0æŸ¥åˆ°s1.length(), s1æœ‰çš„++, s2æœ‰çš„--, ç»“æŸåå¦‚æœall zeros return true
        ä»s1.length() åˆ°s2.length(), æ¯ä¸€æ­¥s2æœ‰çš„++, s2[i - s1.length()]++, æ¯ä¸€æ­¥éƒ½è¦æŸ¥æ˜¯å¦all zeros
        all zeros considers as o(1) operation(only 26 charsï¼‰
    209 [sum >= s] https://leetcode.com/problems/minimum-size-subarray-sum/
    
    
    
22. Two Pointers
    (1) Intersection
        é‡å¤çš„æ˜¯å¦è®¡ç®—å…¥ç»“æœï¼Ÿï¼Ÿ
        349 ä¸ç®— åªè®°ä¸€æ¬¡ ç”¨hashset, ç®—å®Œå°±erase https://leetcode.com/problems/intersection-of-two-arrays/
        350 ç®— num2å‡ºç°åœ¨ä¸åŒä½ç½®ä¸Šçš„åŒä¸€ä¸ªæ•°matchåˆ°äº†éƒ½ç®—å…¥ç»“æœ https://leetcode.com/problems/intersection-of-two-arrays-ii/
            ç”¨hashmap, matchä¸€æ¬¡å‡ä¸€æ¬¡
        1213 https://leetcode.com/problems/intersection-of-three-sorted-arrays/
             ä¸‰ä¸ªæŒ‡é’ˆ, æ¯æ¬¡push backæœ€å°çš„ç„¶å++
        160 https://leetcode.com/problems/intersection-of-two-linked-lists/
            while (pa != pb) {
              pa = (pa) ? pa->next : headB;
              pb = (pb) ? pb->next : headA;
            }
     (2) Merge
         88 [2 while loops] https://leetcode.com/problems/merge-sorted-array/
         å…ˆä»åå¾€å‰åŒæ—¶ç§»åŠ¨ij
         å¦‚æœnum1ç§»åˆ°å¼€å§‹ä½†nums2è¿˜æœ‰å‰©ä¸‹çš„,è¿˜éœ€è¦ä¸€ç›´æŠŠnums2å‰©ä¸‹çš„ç§»è¿›å»
         
23. DP
    1027 https://leetcode.com/problems/longest-arithmetic-sequence/
    nested for loop æ‰€æœ‰çš„combinationï¼Œå‡å‡ºdistanceï¼Œdp[dist][i] = dp[dist].count(j) ? dp[dist][j] + 1 : 2;
    å¯¹æ¯ä¸€ä¸ªdp[dist][i]å»max return
    161 https://leetcode.com/problems/one-edit-distance/
    72 https://leetcode.com/problems/edit-distance/
    91 https://leetcode.com/problems/decode-ways/
       dp[0] = 1, dp[1] = s[0] == '0' ? 0 : 1;
       for loop starts from 2 to n]
    691 https://leetcode.com/problems/wildcard-matching/
       
24. Strobogrammatic number
    246 https://leetcode.com/problems/strobogrammatic-number/
        Write a function to determine if a number is strobogrammatic.
        å‰åä¸¤ä¸ªpointeræŸ¥æ˜¯å¦match, matchåŒ…æ‹¬018ä¸€æ ·, 6match9, 9match6,å¦‚æœéƒ½ä¸æ˜¯return false
    247 https://leetcode.com/problems/strobogrammatic-number-ii/
        Find all strobogrammatic numbers that are of length = n.
        dfs with left right boundary, hardcode every pair
        æ³¨æ„å¦‚æœleft = 0ä¸èƒ½æ”¾(0,0)

25. Use nums[i] as index 
    [binary search] 1060 https://leetcode.com/problems/missing-element-in-sorted-array/ right starts from nums.size()
    
26. Sorting 
    969 O(n^2) https://leetcode.com/problems/pancake-sorting/
        search from the maximum(size), fint the index
        Reverse from beginning to index, to make search at A[0], push i + 1;
        Reverse from beginning to search, to make search at position, push search;
        
     
    
next permutation
