1. Sum

 (1) Prefix-Sum, Hashmap
 
   523 https://leetcode.com/problems/continuous-subarray-sum/

   560 https://leetcode.com/problems/subarray-sum-equals-k/

   325 https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/

   (!) 209 https://leetcode.com/problems/minimum-size-subarray-sum/solution/
   Find the continous subarray sum >= s

   Using pre-fix sum O(nlogn), no hashmap
   Use pre-fix sum array and find sum + s lower_bound in log(n)

   Using two pointer O(n)

   304 https://leetcode.com/problems/range-sum-query-2d-immutable/
   2D Pre-fix Sum array O(1) get function
   303 https://leetcode.com/problems/range-sum-query-immutable/
   Simple Pre-fix Sum array O(1) get function

   689 https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/
   In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.
   Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.
   Return the result as a list of indices representing the starting position of each interval (0-indexed). 
   If there are multiple answers, return the lexicographically smallest one.
   Input: [1,2,1,2,6,7,5,1], 2
   Output: [0, 3, 5]
   Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
   We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

   Pre-sum, Store index in pos_left, pos_right(pos_right[i] = i + k)
   pos_left[i] = i - k, from k to n - 2k, (further no enough space on the right for mid and right parts)
   pos_right[i] = i + k, from n - 2k to k
   loop from k to n - 2k 
 
 (2) DP
   416 https://leetcode.com/problems/partition-equal-subset-sum/
   Given a non-empty array containing only positive integers, 
   find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
   Input: [1, 5, 11, 5]
   Output: true
   Explanation: The array can be partitioned as [1, 5, 5] and [11].
   
   494 https://leetcode.com/problems/target-sum/
   You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. 
   Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
   Find out how many ways to assign symbols to make sum of integers equal to target S.
   
   Brute Force: DFS, O(2^n) n: size of array.
   From index 0 to n - 1, try +nums[i], -nums[i] every call of dfs.
   
   DP: (The sum of elements in the given array will not exceed 1000.) So use 2d dp array of size n * 2001.
   
   Base: dp[0][nums[0] + 1000] = 1, dp[0][-nums[0] + 1000] += 1.
   For i from 0 to n - 1
    For sum from -1000 to 1000
      if (dp[i][sum + 1000] > 0)
        dp[i][sum + 1000 + nums[i]] += dp[i - 1][sum + 1000];
        dp[i][sum + 1000 - nums[i]] += dp[i - 1][sum + 1000];
   Return dp[n - 1][S + 1000];    
   
 
 (3) Other
   15 https://leetcode.com/problems/3sum/
   1 https://leetcode.com/problems/2sum/
 
 (4) Nested List
   339 https://leetcode.com/problems/nested-list-weight-sum/
   Input: [[1,1],2,[1,1]]
   Output: 10 
   Explanation: Four 1's at depth 2, one 2 at depth 1.
   
   Basic DFS, add one level each list
   
   364 https://leetcode.com/problems/nested-list-weight-sum-ii/
   Input: [[1,1],2,[1,1]]
   Output: 8 
   Explanation: Four 1's at depth 1, one 2 at depth 2.
   
   Input: [1,[4,[6]]]
   Output: 17 
   Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.
   
   The most inner Integer is at level 1.
   Two int variables, weighted and unweighted. 
   unweighted += item.getInteger();
   If !item.isInteger(), push the list into next level
   swap two list
   
   
   
 
 (5) Binary Tree Path
   124 https://leetcode.com/problems/binary-tree-maximum-path-sum/
   
   129 https://leetcode.com/problems/sum-root-to-leaf-numbers/
   DFS, pass sum * 10 + root->val as new sum to next level(children)
   
   113 https://leetcode.com/problems/path-sum-ii/
   DFS, base: check target == root->val
   Use reference, no RETURN in check condition. 
 (6) Backtrack in Array
   39 https://leetcode.com/problems/combination-sum/
   DFS, start with every index, (next dfs may start with the same index)
   To avoid duplicates: 1. no dulicates in the input, 2. sort before dfs.
   
  
  
2. DFS Backtrack
(1) Add operation

494 https://leetcode.com/problems/target-sum/
+ or - on every number 
Can be optimized using dp


3. Palindrome
  266 https://leetcode.com/problems/palindrome-permutation/
  这个题和Palindrome几乎无关。
  最优解是用hashmap存一次每个char的次数，然后再loop一次，maintain一个count variable，每次碰到出现次数为1的count++，当count大于1直接break
  return count <= 1
  
  680 https://leetcode.com/problems/valid-palindrome-ii/
  You may delete at most one character. Judge whether you can make it a palindrome.

  Two pointer, from the beginning and the end, 
  if not the same, try remove one of them and check the rest need to be a valid Palindrome.
  
  1216. Valid Palindrome III https://leetcode.com/problems/valid-palindrome-iii/
  
  Brute Force: DFS
  
  Optimized: DFS with memo O(n^2), hardcore is to find a workable hash function
  i * 1001 * 1001 + j * 1001 + k, OR hash string i + "," + j + "," + k
  
  Optimized: DP Longest subsequence, return dp[0][n - 1] + k >= n

  125 https://leetcode.com/problems/valid-palindrome/
  Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
  Input: "A man, a plan, a canal: Panama"
  Output: true

  Two pointer, from the beginning and the end, 
  while not isalnum i++, j--, compare lowercase and move pointers.

  9 https://leetcode.com/problems/palindrome-number/

  Two corner cases: 1. negative return false directly, 2. x % 10 == 0 && x != 0, false directly.
  O(log(n)), while x > last_half, x /= 10 each iteration and keep track of the reversed last half.

  647 https://leetcode.com/problems/palindromic-substrings/（似乎有一个O(1) time solution）
  Given a string, your task is to count how many palindromic substrings in this string.
  The substrings with different start indexes or end indexes are counted as different substrings 
  even they consist of same characters.

  2D DP n * n
  Initialization: dp[i][i] = 1; count = n;
  For i from n - 2 to 0
    For j from i + 1 to n
      If (s[i] == s[j]) 
         If (j == i + 1) dp[i][j] = 1;
         Else dp[i][j] = dp[i + 1][j - 1];
      count += dp[i][j];
  return count;

  O(1) memory:
  int n = s.length(), count = 0;
  for (int i = 0; i < n; i++) {
      for (int l = i, r = i; l >= 0 && r < n && s[l] == s[r]; l--, r++) count++;
      for (int l = i, r = i + 1; l >= 0 && r < n && s[l] == s[r]; l--, r++) count++;
  }
  return count;
  
  5 https://leetcode.com/problems/longest-palindromic-substring/
  Palindromic substring的dp题可以用expandAroundCenter的办法将space降至O(1)
  
  string longestPalindrome(string s) {
      int n = s.length(), start = 0, end = 0;
      for (int i = 0; i < n; i++) {
          int lenOdd = expandAroundCenter(s, i, i);
          int lenEven = expandAroundCenter(s, i, i + 1);
          int len = max(lenOdd, lenEven);
          if (len > (end - start)) {
              end = i + len / 2;
              start = i - (len - 1) / 2;
          }
      }
      return s.substr(start, end - start + 1);
  }
  int expandAroundCenter(string& s, int i, int j) {
      int left = i, right = j, n = s.length();
      while (left >= 0 && right < n && s[left] == s[right]) {
          left--, right++;
      }
      return right - left - 1;
  }
  
  516 https://leetcode.com/problems/longest-palindromic-subsequence/
  2D DP(n * n)
  dp[i][j] longest palindromic subsequence from i to j inclusive
  init: dp[i][i] = 1;
  return: from 0 to n - 1 dp[0][n - 1]
  int longestPalindromeSubseq(string s) {
      int n = s.length();
      vector<vector<int>> dp(n, vector<int>(n, 0));
      for (int i = 0; i < n; i++) dp[i][i] = 1;
      for (int i = n - 2; i >= 0; i--) {
          for (int j = i + 1; j < n; j++) {
              if (s[i] == s[j]) {
                  if (j == i + 1) dp[i][j] = 2;
                  else dp[i][j] = dp[i + 1][j - 1] + 2;
              } else {
                  dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
              }
          }
      }
      return dp[0][n - 1];
  }
  
  214 https://leetcode.com/problems/shortest-palindrome/
  O(n^2): T(n) = T(n - 2) + O(n) 
  Two pointers, from begining and end, i increase by one when s[i] == s[j]
  if i == n return s;
  extra = s.substr(i) is the extra part in this call.
  ret = reversed(extra) + shortestPalindrome(s.substr(0, i)) + extra;
  
  336 https://leetcode.com/problems/palindrome-pairs/
  Brute force: concatenate every two of the strings and call checkValid() O(n^2 * k)
  Optimized: O(k^2 * n)
  Build hashmap containing reversed words from input as key, the index in input as value.
  For i from 0 to n - 1
    For j from 0 to n - i?
      string left = words[i].substr(0, j);
      string right = words[i].substr(j + 1);
      if (dict.find(left) != dict.end() && dict[left] != i && isPalindrome(right)) ret.push_back({i, dict[left]});
      if (dict.find(right) != dict.end() && dict[right] != i && isPalindrome(left) && !left.empty()) ret.push_back({dict[right], i});
  
4. Search
(1) The Maze
490 https://leetcode.com/problems/the-maze/

DFS, return bool, O(m*n)
Start DFS from start[0],start[1].
Base case: out of bound(4) || if maze[row][col] != 0
Mark Visited: maze[row][col] = 2;
Try four direction(while loop) until the end(hit a wall), do dfs from the end
return dfs(left) || dfs(right) || dfs(up) || dfs(down).

505 https://leetcode.com/problems/the-maze-ii/

Find the shortest distance for the ball to stop at the destination
BFS O(m*n) return pathLength
Build another distance 2D vector, starting with INT_MAX, and update it duing the traversal.
Return dist[end[0]][end[1]] == INT_MAX ? -1 : dist[end[0]][end[1]];

(2) Walls and Gates/Shortest Distance from All Buildings
286 https://leetcode.com/problems/walls-and-gates/
Fill each empty room with the distance to its nearest gate. 
If it is impossible to reach a gate, it should be filled with INF

DFS/BFS
Do search on every gate, 
Update when grid[next_r][next_c] > grid[r][c] + 1, 
Start next search from (next_r, next_c) 

317 https://leetcode.com/problems/shortest-distance-from-all-buildings/
BFS 这道题因为要sum up all distance，所以更新visited的方式是对于每一个building的search，要找的target数字不一样
第一个building search 0，每个push进queue的空地都要grid[][]--；对于下一个building， search -1， 以此类推。




